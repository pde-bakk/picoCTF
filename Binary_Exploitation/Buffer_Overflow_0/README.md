# Buffer overflow 0

We use our trusted [buffer overflow pattern generator](https://wiremask.eu/tools/buffer-overflow-pattern-generator/)

At first I was trying to get the offset and got the flag on accident. I had overlooked the fact that they set up a signalhandler for segfaults.

So here, all you need to do is trigger a segfault so it spits out the flag.

```c
#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
	printf("%s\n", flag);
	fflush(stdout);
	exit(1);
}
```

How do you do that?
This program actually has two seperate vulnerabilities. Both `gets` and `strcpy` are vulnerable.
When the program asks for input, give it more than it can handle (more than 28 characters).
Both `gets` and `strcpy` will take your entire string and try to fit it into their destination buffer. Which can cause a crash if the buffer isn't large enough to hold your entire string.
